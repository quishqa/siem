{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This the SImplied Emission Model (SIEM). It is a python package to create the emission file for WRF-Chem and CMAQ air quality models.</p> <p>It is inspired in the works of Andrade et al. (2015), AAS4WRF, PyChEmiss.</p> <p>This documentation used the diaxtasis approach. It is structured as follows:</p> <ol> <li>Tutorial: Example to start creating your emissions.</li> <li>How to guides: Examples in more detailed about specific tasks.</li> <li>Explanation: The motivation to create this package.</li> <li>Reference: A guide of the classes and functions of the package.</li> </ol>"},{"location":"explanation/","title":"Explanation","text":"<p><code>siem</code> package helps you to create the emission files for WRF-Chem, and CMAQ air quality models. The strategy is to reproduces the model's netCDF emission files (same coordinates, dimensions, units, and attributes). As sometimes the original emission pre-processors requires very detailed information, <code>siem</code> allows the user to create the emissions with limited information, and hence the simplified in the name. Because of that, <code>siem</code> could be used in different cities to run air quality models, and, therefore, to improve air quality management.</p> <p><code>siem</code> is strongly based on the methodology of Andrade et al. (2015), previously used in many air quality simulation over the Metropolitan Area of S\u00e3o Paulo. But, <code>siem</code> offers other features:</p> <ul> <li>Adding different number of emission sources.</li> <li>Point sources can be spatially and temporal distributed.</li> <li>It is chemical mechanism agnostic. The chemical mechanism are not hard-coded.</li> <li>Emission sources can vary by day of the week.</li> <li>Each emission sources can have different spatial distribution.</li> <li>Early created for WRF-Chem, but now compatible with CMAQ.</li> <li>As it is built in Python, subproducts can be easily modified (i.e. calculate total emissions, plot pollutant emissions, apply correction factors, etc).</li> </ul>"},{"location":"how-to-guides/","title":"How-to guides","text":""},{"location":"how-to-guides/#how-to-create-the-spatial-proxy","title":"How to create the spatial proxy","text":"<p><code>siem</code> comes with functions to create a spatial proxy for vehicular emissions using the OpenStreetMap data. It follows the methodology to spatially distributes emissions described in Andrade et al. (2015).</p> <p>To create the spatial proxy we need to:</p> <ul> <li>Download the highways data from OpenStreetMap.</li> <li>Calculate proxy.</li> </ul>"},{"location":"how-to-guides/#download-highways-data","title":"Download highways data","text":"<p>For this example we will download the <code>primary</code>, <code>motorway</code>, and <code>trunk</code> highways, to distributes our vehicular emissions.</p> <p>List of highways types to download</p> <p>You can see a list of highways to download from this site: key:highways. See what is the best highway to distribute the vehicular emissions.</p> <p>To this goal we use <code>download_highways()</code> function from <code>proxy</code> module.</p> <pre><code>from siem.proxy import download_highways\n\ngeogrid_path = './geo_em.d01.nc'\nhighways_list = ['primary', 'motorway', 'trunk']\n\ncity_highways = download_highways(\n  geo_em_path=geogrid_path,\n  highway_type=highways_list,\n  add_links=False,\n  save=True,\n  save_path='./highway_data/partial',\n  file_name='highways_d01'\n)\n</code></pre> <p>Depending on the domain size and the number of highways types it could take some time. It will save data in <code>./highway_data/partial/domain_highways_d01.graphml</code></p> <p>The download could take a lot of time</p> <p>You can leave the process running in the background by saving it  in a python script and running by: <pre><code>nohup python download_proxy.py &amp;\n</code></pre></p>"},{"location":"how-to-guides/#calculate-proxy","title":"Calculate proxy","text":"<p>Now that you have the highways data, we need to calculate the proxy. That is, we need to calculate the weight in each domain cell. <code>siem</code> assume that the number of vehicles inside a domain cell is proportional to the sum of highways lengths inside that cell.</p> <p>To do this calculation, and create the proxy file ready to use in <code>EmissionSorce</code>, we use the <code>create_wrf_grid()</code>, <code>load_osmx_to_gdfs()</code>, and <code>calculate_highway_grid()</code> functions from <code>proxy</code> module.</p> <pre><code>from siem.proxy import (create_wrf_grid, load_osmx_to_gdfs, calculate_highway_grid)\n\ngeogrid_path = \"./geo_em.d01.nc\"\nhighways_path = \"./highways_data/partial/domain_highways_d01.graphml\"\n\nhighways = load_osmx_to_gdfs(highways_path)\nwrf_grid = create_wrf_grid(geogrid_path)\nhighways_in_grid = calculate_highway_grid(\n  wrf_grid=wrf_grid,\n  proxy=highways,\n  to_pre=True,\n  save_pre=\"./highways_data/\",\n  file_name=\"d01\"\n)\n</code></pre> <p>This script will create the <code>.csv</code> (<code>./highways_data/highways_d01.csv</code>) to be used in <code>EmissionSorce</code>.</p>"},{"location":"how-to-guides/#how-to-create-wrf-chem-emission-file","title":"How to create WRF-Chem emission file","text":"<p>All <code>siem</code> objects have the method <code>.to_wrfchemi()</code> that is used to build the WRF-Chem emission file. Let's create the emission file of the gasoline vehicles emissions in the tutorial example.</p> <pre><code>gasoline = EmissionSource(\n  name=\"Gasoline vehicles\",\n  number=1_000_000,\n  use_intensity=13_495/365,\n  spatial_proxy=gasoline_spatial_proxy,\n  temporal_profile=temp_prof,\n  voc_spc=gasoline_voc_cbmz,\n  pm_spc=gasoline_pm_mosaic\n)\n</code></pre> <p>So, to create the emission file we can do:</p> <pre><code>wrfinput_d01 = xr.open_dataset('./wrfinput_d01')\n\ngasoline.to_wrfchemi(\n  wrfinput=wrfinput_d01,\n  start_date='2025-10-01',\n  end_date='2025-10-01',\n  week_profile=[1],\n  pm_name='PM',\n  voc_name='VOC',\n  write_netcdf=True,\n  nc_format='NETCDF3_64BIT',\n  path='./'\n)\n</code></pre> <p>This code chunk will produce the wrfchemi file in <code>io_style_emissions=1</code>. That is a standard emission file split in 12 hours: <code>wrfchemi_00z_d01</code> and <code>wrfchemi_12z_d01</code>.</p> <p>To create the wrfchemi file in <code>io_style_emissions=2</code>, we need to play with <code>start_date</code>, <code>end_date</code>, and <code>week_profile</code> arguments. First if we want emission for a week, we can change the range of the start and end dates.</p> <p>But if we want to add a week of the day variation, for example, lets say that on the weekends we have half the emissions of the weekday, we can define this variations by a <code>list()</code> with seven elements going from Monday to Sunday.</p> <pre><code>wrfinput_d01 = xr.open_dataset('./wrfinput_d01')\nweek_profile = [1, 1, 1, 1, 1, 0.5, 0.5]\n\ngasoline.to_wrfchemi(\n  wrfinput=wrfinput_d01,\n  start_date='2025-10-01',\n  end_date='2025-10-07',\n  week_profile=week_profile,\n  pm_name='PM',\n  voc_name='VOC',\n  write_netcdf=True,\n  nc_format='NETCDF3_64BIT',\n  path='./'\n)\n</code></pre> <p>This code will produce the file <code>wrfchemi_d01_2025-10-01_00:00:00</code>, and the weekends will have half the emissions of the week of the day.</p> <p>Checking the times of wrfchemi files</p> <p>You can use the command: <pre><code>ndump -v Times wrfchemi_d01_2025-10-01_00\n</code></pre> To check the number of times, and the start and end date of the emission files Also to check the day of the week variation, you can use <code>ncview</code>.</p>"},{"location":"how-to-guides/#how-to-create-cmaq-file","title":"How to create CMAQ file","text":"<p>Something similar is required to create the emission files for CMAQ. The main difference is the need of extra inputs, the <code>GRIDDESC``** file and the **</code>BTRIM` value. That is the output of MCIP outputs.</p> <p>In this case we use the <code>.to_cmaq()</code> method. Following the same example:</p> <pre><code>wrfinput_d01 = xr.open_dataset('./wrfinput_d01')\nweek_profile = [1, 1, 1, 1, 1, 0.5, 0.5]\n\ngasoline.to_cmaq(\n  wrfinput=wrfinput_d01,\n  griddesc_path='./GRIDDESC',\n  btrim=5,\n  start_date='2025-10-01',\n  end_date='2025-10-07',\n  week_profile=week_profile,\n  pm_name='PM',\n  voc_name='VOC',\n  write_netcdf=True,\n  path='./'\n)\n</code></pre> <p>This will create a daily emission file, one for each day of the range between start and end dates.</p> <p>Warning</p> <p><code>to_cmaq()</code> requires a <code>week_profile</code> of at least 7 elements. If there is no information available you can make a list full of ones.</p>"},{"location":"reference/","title":"SIEM Reference","text":"<p>Here is the detailed information of SIEM classes and functions.</p> <p>SIEM: SImplified Emission Model.</p> <p>SIEM produces the emission file required to run WRF-Chem and CMAQ air quality models.</p> This modules defined the classes used by siem to create this emissions files <ul> <li><code>EmissionSource</code> - Class to spatially and temporal distribute emissions, especially vehicular emissions.</li> <li><code>PointSources</code> - Class to spatially and temporal distribute point sources from a .csv table.</li> <li><code>GroupSources</code> - Class to group EmissionSources and PointSources, useful to create one emission file.</li> </ul>"},{"location":"reference/#siem.siem.EmissionSource","title":"<code>EmissionSource</code>","text":"<p>Emission source.</p> <p>A class used to represent and emission source to be estimated from spatial proxy.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>Name of Source.</p> <code>number</code> <p>Number of Sources.</p> <code>use_intensity</code> <p>Use intensity</p> <code>pol_ef</code> <p>Pollutant emission factors and molecular weight.</p> <code>spatial_proxy</code> <p>Spatial proxy to spatial distribute emissions.</p> <code>temporal_prof</code> <p>Temporal profile to temporal distribute emissions.</p> <code>voc_spc</code> <p>VOC species to speciate with their fraction.</p> <code>pm_spc</code> <p>PM species to speciate with their fraction.</p> Source code in <code>siem/siem.py</code> <pre><code>class EmissionSource:\n    \"\"\"Emission source.\n\n    A class used to represent and emission source to\n    be estimated from spatial proxy.\n\n    Attributes:\n        name: Name of Source.\n        number: Number of Sources.\n        use_intensity: Use intensity\n        pol_ef: Pollutant emission factors and molecular weight.\n        spatial_proxy: Spatial proxy to spatial distribute emissions.\n        temporal_prof: Temporal profile to temporal distribute emissions.\n        voc_spc: VOC species to speciate with their fraction.\n        pm_spc: PM species to speciate with their fraction.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        number: int | float,\n        use_intensity: float,\n        pol_ef: dict,\n        spatial_proxy: xr.DataArray,\n        temporal_prof: list[float],\n        voc_spc: dict,\n        pm_spc: dict,\n    ):\n        \"\"\"Create the EmissionSource object.\n\n        Args:\n            name: Name of the source.\n            number: Number of sources (e.g., number of vehicles)\n            use_intensity: Emission source activity rate.\n            pol_ef: Keys are pollutants in the inventory.\n                Values are a tuple with pollutant emission factors and molecular weight.\n            spatial_proxy: Proxy to spatially distribute emissions.\n            temporal_prof: Hourly fractions to temporally distribute emissions.\n            voc_spc: Keys are VOC species.Values are the fraction of the total VOC.\n            pm_spc: Keys are PM species. Values are the fraction of the total PM.\n        \"\"\"\n        self.name = name\n        self.number = number\n        self.use_intensity = use_intensity\n        self.pol_ef = pol_ef\n        self.spatial_proxy = spatial_proxy\n        self.temporal_prof = temporal_prof\n        self.voc_spc = voc_spc\n        self.pm_spc = pm_spc\n\n    def __str__(self):\n        \"\"\"Print summary of EmissionSource attributes.\n\n        Returns:\n            Print name, number, pollutants,\n            and VOC and PM species information\n            from EmissionSource.\n        \"\"\"\n        source_summary = (\n            f\"Source name: {self.name}\\n\"\n            f\"Number: {self.number}\\n\"\n            f\"Pollutants: {list(self.pol_ef.keys())}\\n\"\n            f\"Number VOC species: {len(self.voc_spc.keys())}\\n\"\n            f\"Number PM species: {len(self.pm_spc.keys())}\\n\"\n        )\n        return source_summary\n\n    def total_emission(self, pol_name: str, ktn_year: bool = False) -&gt; float:\n        \"\"\"Calculate total emission of a pollutant.\n\n        Args:\n            pol_name: Pollutant name to calculate the total emission.\n            ktn_year: If total is calculated in KTn (Gg) year^-1\n\n        Returns:\n            Total emission of a pollutant.\n        \"\"\"\n        total_emiss = em.calculate_emission(\n            self.number, self.use_intensity, self.pol_ef[pol_name][0]\n        )\n        # units of total_emiss in g day^-1\n\n        if ktn_year:\n            return total_emiss * 365 / 10**9\n        return total_emiss\n\n    def report_emissions(self) -&gt; pd.DataFrame:\n        \"\"\"Return the total emission for each pollutant in pol_ef.\n\n        Returns:\n            A table with pollutants as index and total emissions\n            as columns.\n        \"\"\"\n        total_emission = {\n            pol: self.total_emission(pol, ktn_year=True) for pol in self.pol_ef.keys()\n        }\n        total_emission = pd.DataFrame.from_dict(\n            total_emission, orient=\"index\", columns=[\"total_emiss\"]\n        )\n        return total_emission\n\n    def spatial_emission(self, pol_name: str, cell_area: int | float) -&gt; xr.DataArray:\n        \"\"\"Distribute one pollutant.\n\n        Args:\n            pol_name: Key value in pol_ef.\n            cell_area: Area of wrfinput.\n\n        Returns:\n            Spatially distributed emissions.\n        \"\"\"\n        return spt.distribute_spatial_emission(\n            self.spatial_proxy,\n            self.number,\n            cell_area,\n            self.use_intensity,\n            self.pol_ef[pol_name][0],\n            pol_name,\n        )\n\n    def spatiotemporal_emission(\n        self, pol_names: str | list[str], cell_area: int | float, is_cmaq: bool = False\n    ) -&gt; xr.DataArray:\n        \"\"\"Spatial and temporal distribution of emissions.\n\n        Args:\n            pol_names: Name or names of pollutants to distribute.\n            cell_area: Wrfinput cell area.\n            is_cmaq: If it will be used for CMAQ.\n\n        Returns:\n            Spatial and temporal emission distribution.\n        \"\"\"\n        if isinstance(pol_names, str):\n            pol_names = [pol_names]\n\n        spatial_emissions = {\n            pol: self.spatial_emission(pol, cell_area) for pol in pol_names\n        }\n\n        temp_prof = self.temporal_prof\n        if is_cmaq:\n            temp_prof = cmaq.to_25hr_profile(self.temporal_prof)\n\n        spatio_temporal = {\n            pol: temp.split_by_time(spatial, temp_prof)\n            for pol, spatial in spatial_emissions.items()\n        }\n        return xr.merge(spatio_temporal.values())\n\n    def speciate_emission(\n        self,\n        pol_name: str,\n        pol_species: dict,\n        cell_area: int | float,\n        is_cmaq: bool = False,\n    ) -&gt; xr.DataArray:\n        \"\"\"Speciate one pollutant emissions. Used especially for VOC or NOX.\n\n        Args:\n            pol_name: Pollutant name in pol_ef to speciate.\n            pol_species: Keys are pollutants speciated from pol_name.\n                Values are the fraction.\n            cell_area: wrfinput cell area km^2\n            is_cmaq: If output is for CMAQ.\n\n        Returns:\n            Spatial and temporal distribution of speciated emission.\n        \"\"\"\n        spatio_temporal = self.spatiotemporal_emission(pol_name, cell_area, is_cmaq)\n        speciated_emiss = em.speciate_emission(\n            spatio_temporal, pol_name, pol_species, cell_area\n        )\n        return speciated_emiss\n\n    def speciate_all(\n        self,\n        cell_area: int | float,\n        voc_name: str = \"VOC\",\n        pm_name: str = \"PM\",\n        is_cmaq: bool = False,\n    ) -&gt; xr.Dataset:\n        \"\"\"Speciate VOC and PM.\n\n        Args:\n            cell_area: wrfinput cell area.\n            voc_name: Name of VOC in pol_ef keys.\n            pm_name: Name of PM in pol_ef keys.\n            is_cmaq: If output for CMAQ.\n\n        Returns:\n            Spatial and temporal distributed emissions with\n            VOC and PM speciated.\n        \"\"\"\n        spatio_temporal = self.spatiotemporal_emission(\n            self.pol_ef.keys(), cell_area, is_cmaq\n        )\n        speciated_emiss = em.speciate_emission(\n            spatio_temporal, voc_name, self.voc_spc, cell_area\n        )\n        speciated_emiss = em.speciate_emission(\n            speciated_emiss, pm_name, self.pm_spc, cell_area\n        )\n        return speciated_emiss\n\n    def to_wrfchemi(\n        self,\n        wrfinput: xr.Dataset,\n        start_date: str,\n        end_date: str,\n        week_profile: list[float] = [1],\n        pm_name: str = \"PM\",\n        voc_name: str = \"VOC\",\n        write_netcdf: bool = False,\n        nc_format: str = \"NETCDF3_64BIT\",\n        path: str = \"../results\",\n    ) -&gt; xr.Dataset:\n        \"\"\"Create WRF-Chem emission file (wrfchemi).\n\n        Args:\n            wrfinput: WRF-Chem wrfinput file.\n            start_date: Start date of emissions.\n            end_date: End date of emissions.\n            week_profile: List of seven fraction of each week day.\n            pm_name: PM name in pol_ef keys.\n            voc_name: VOC name in pol_ef keys\n            write_netcdf: Write the NetCDF file.\n            nc_format: wrfchemi NetCDF file format.\n            path: Location to save wrfchemi.\n\n        Returns:\n            Dataset with wrfchemi netCDF format.\n        \"\"\"\n        cell_area = (wrfinput.DX / 1000) ** 2\n        spatio_temporal = self.spatiotemporal_emission(self.pol_ef.keys(), cell_area)\n        if len(week_profile) == 7:\n            spatio_temporal = temp.split_by_weekday(\n                spatio_temporal, week_profile, start_date, end_date\n            )\n        spatio_temporal = wemi.transform_wrfchemi_units(\n            spatio_temporal, self.pol_ef, pm_name\n        )\n        speciated_emiss = wemi.speciate_wrfchemi(\n            spatio_temporal,\n            self.voc_spc,\n            self.pm_spc,\n            cell_area,\n            wrfinput,\n            voc_name,\n            pm_name,\n        )\n        wrfchemi_netcdf = wemi.prepare_wrfchemi_netcdf(\n            speciated_emiss, wrfinput, start_date\n        )\n\n        if write_netcdf:\n            wemi.write_wrfchemi_netcdf(wrfchemi_netcdf, nc_format, path)\n        return wrfchemi_netcdf\n\n    def to_cmaq(\n        self,\n        wrfinput: xr.Dataset,\n        griddesc_path: str,\n        btrim: int,\n        start_date: str,\n        end_date: str,\n        week_profile: list[float] = [1],\n        pm_name: str = \"PM\",\n        voc_name: str = \"VOC\",\n        write_netcdf: bool = False,\n        path: str = \"../results\",\n    ) -&gt; typing.Dict[str, xr.Dataset]:\n        \"\"\"Create CMAQ emission file.\n\n        Args:\n            wrfinput: wrfinput from WRF simulation.\n            griddesc_path: Location of GRIDDESC file.\n            btrim: BTRIM option in MCIP.\n            start_date: Start date of emission files.\n            end_date: End date of emission files.\n            week_profile: List of seven fraction of each week day.\n            pm_name: PM name in pol_ef keys.\n            voc_name: VOC name in pol_ef keys.\n            write_netcdf: Write the netCDF file.\n            path: Location to save CMAQ emission file.\n\n        Returns:\n            Keys are simulation days and values the emission file for CMAQ\n            for that day.\n        \"\"\"\n        cell_area = (wrfinput.DX / 1000) ** 2\n        spatio_temporal = self.spatiotemporal_emission(\n            self.pol_ef.keys(), cell_area, is_cmaq=True\n        )\n        spatio_temporal_units = cmaq.transform_cmaq_units(\n            spatio_temporal, self.pol_ef, cell_area\n        )\n        speciated_emiss = cmaq.speciate_cmaq(\n            spatio_temporal_units, self.voc_spc, self.pm_spc, cell_area\n        )\n\n        # TODO: Change it to a function\n        for emi in speciated_emiss.data_vars:\n            speciated_emiss[emi] = speciated_emiss[emi].astype(\"float32\")\n\n        days_factor = temp.assign_factor_simulation_days(\n            start_date, end_date, week_profile, is_cmaq=True\n        )\n        cmaq_files = {\n            day: cmaq.prepare_netcdf_cmaq(\n                speciated_emiss * fact,\n                day,\n                griddesc_path,\n                btrim,\n                self.voc_spc,\n                self.pm_spc,\n            )\n            for day, fact in zip(days_factor.day, days_factor.frac)\n        }\n        if write_netcdf:\n            for cmaq_nc in cmaq_files.values():\n                cmaq.save_cmaq_file(cmaq_nc, path)\n        return cmaq_files\n</code></pre>"},{"location":"reference/#siem.siem.EmissionSource.__init__","title":"<code>__init__(name, number, use_intensity, pol_ef, spatial_proxy, temporal_prof, voc_spc, pm_spc)</code>","text":"<p>Create the EmissionSource object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the source.</p> required <code>number</code> <code>int | float</code> <p>Number of sources (e.g., number of vehicles)</p> required <code>use_intensity</code> <code>float</code> <p>Emission source activity rate.</p> required <code>pol_ef</code> <code>dict</code> <p>Keys are pollutants in the inventory. Values are a tuple with pollutant emission factors and molecular weight.</p> required <code>spatial_proxy</code> <code>DataArray</code> <p>Proxy to spatially distribute emissions.</p> required <code>temporal_prof</code> <code>list[float]</code> <p>Hourly fractions to temporally distribute emissions.</p> required <code>voc_spc</code> <code>dict</code> <p>Keys are VOC species.Values are the fraction of the total VOC.</p> required <code>pm_spc</code> <code>dict</code> <p>Keys are PM species. Values are the fraction of the total PM.</p> required Source code in <code>siem/siem.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    number: int | float,\n    use_intensity: float,\n    pol_ef: dict,\n    spatial_proxy: xr.DataArray,\n    temporal_prof: list[float],\n    voc_spc: dict,\n    pm_spc: dict,\n):\n    \"\"\"Create the EmissionSource object.\n\n    Args:\n        name: Name of the source.\n        number: Number of sources (e.g., number of vehicles)\n        use_intensity: Emission source activity rate.\n        pol_ef: Keys are pollutants in the inventory.\n            Values are a tuple with pollutant emission factors and molecular weight.\n        spatial_proxy: Proxy to spatially distribute emissions.\n        temporal_prof: Hourly fractions to temporally distribute emissions.\n        voc_spc: Keys are VOC species.Values are the fraction of the total VOC.\n        pm_spc: Keys are PM species. Values are the fraction of the total PM.\n    \"\"\"\n    self.name = name\n    self.number = number\n    self.use_intensity = use_intensity\n    self.pol_ef = pol_ef\n    self.spatial_proxy = spatial_proxy\n    self.temporal_prof = temporal_prof\n    self.voc_spc = voc_spc\n    self.pm_spc = pm_spc\n</code></pre>"},{"location":"reference/#siem.siem.EmissionSource.__str__","title":"<code>__str__()</code>","text":"<p>Print summary of EmissionSource attributes.</p> <p>Returns:</p> Type Description <p>Print name, number, pollutants,</p> <p>and VOC and PM species information</p> <p>from EmissionSource.</p> Source code in <code>siem/siem.py</code> <pre><code>def __str__(self):\n    \"\"\"Print summary of EmissionSource attributes.\n\n    Returns:\n        Print name, number, pollutants,\n        and VOC and PM species information\n        from EmissionSource.\n    \"\"\"\n    source_summary = (\n        f\"Source name: {self.name}\\n\"\n        f\"Number: {self.number}\\n\"\n        f\"Pollutants: {list(self.pol_ef.keys())}\\n\"\n        f\"Number VOC species: {len(self.voc_spc.keys())}\\n\"\n        f\"Number PM species: {len(self.pm_spc.keys())}\\n\"\n    )\n    return source_summary\n</code></pre>"},{"location":"reference/#siem.siem.EmissionSource.report_emissions","title":"<code>report_emissions()</code>","text":"<p>Return the total emission for each pollutant in pol_ef.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A table with pollutants as index and total emissions</p> <code>DataFrame</code> <p>as columns.</p> Source code in <code>siem/siem.py</code> <pre><code>def report_emissions(self) -&gt; pd.DataFrame:\n    \"\"\"Return the total emission for each pollutant in pol_ef.\n\n    Returns:\n        A table with pollutants as index and total emissions\n        as columns.\n    \"\"\"\n    total_emission = {\n        pol: self.total_emission(pol, ktn_year=True) for pol in self.pol_ef.keys()\n    }\n    total_emission = pd.DataFrame.from_dict(\n        total_emission, orient=\"index\", columns=[\"total_emiss\"]\n    )\n    return total_emission\n</code></pre>"},{"location":"reference/#siem.siem.EmissionSource.spatial_emission","title":"<code>spatial_emission(pol_name, cell_area)</code>","text":"<p>Distribute one pollutant.</p> <p>Parameters:</p> Name Type Description Default <code>pol_name</code> <code>str</code> <p>Key value in pol_ef.</p> required <code>cell_area</code> <code>int | float</code> <p>Area of wrfinput.</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>Spatially distributed emissions.</p> Source code in <code>siem/siem.py</code> <pre><code>def spatial_emission(self, pol_name: str, cell_area: int | float) -&gt; xr.DataArray:\n    \"\"\"Distribute one pollutant.\n\n    Args:\n        pol_name: Key value in pol_ef.\n        cell_area: Area of wrfinput.\n\n    Returns:\n        Spatially distributed emissions.\n    \"\"\"\n    return spt.distribute_spatial_emission(\n        self.spatial_proxy,\n        self.number,\n        cell_area,\n        self.use_intensity,\n        self.pol_ef[pol_name][0],\n        pol_name,\n    )\n</code></pre>"},{"location":"reference/#siem.siem.EmissionSource.spatiotemporal_emission","title":"<code>spatiotemporal_emission(pol_names, cell_area, is_cmaq=False)</code>","text":"<p>Spatial and temporal distribution of emissions.</p> <p>Parameters:</p> Name Type Description Default <code>pol_names</code> <code>str | list[str]</code> <p>Name or names of pollutants to distribute.</p> required <code>cell_area</code> <code>int | float</code> <p>Wrfinput cell area.</p> required <code>is_cmaq</code> <code>bool</code> <p>If it will be used for CMAQ.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>Spatial and temporal emission distribution.</p> Source code in <code>siem/siem.py</code> <pre><code>def spatiotemporal_emission(\n    self, pol_names: str | list[str], cell_area: int | float, is_cmaq: bool = False\n) -&gt; xr.DataArray:\n    \"\"\"Spatial and temporal distribution of emissions.\n\n    Args:\n        pol_names: Name or names of pollutants to distribute.\n        cell_area: Wrfinput cell area.\n        is_cmaq: If it will be used for CMAQ.\n\n    Returns:\n        Spatial and temporal emission distribution.\n    \"\"\"\n    if isinstance(pol_names, str):\n        pol_names = [pol_names]\n\n    spatial_emissions = {\n        pol: self.spatial_emission(pol, cell_area) for pol in pol_names\n    }\n\n    temp_prof = self.temporal_prof\n    if is_cmaq:\n        temp_prof = cmaq.to_25hr_profile(self.temporal_prof)\n\n    spatio_temporal = {\n        pol: temp.split_by_time(spatial, temp_prof)\n        for pol, spatial in spatial_emissions.items()\n    }\n    return xr.merge(spatio_temporal.values())\n</code></pre>"},{"location":"reference/#siem.siem.EmissionSource.speciate_all","title":"<code>speciate_all(cell_area, voc_name='VOC', pm_name='PM', is_cmaq=False)</code>","text":"<p>Speciate VOC and PM.</p> <p>Parameters:</p> Name Type Description Default <code>cell_area</code> <code>int | float</code> <p>wrfinput cell area.</p> required <code>voc_name</code> <code>str</code> <p>Name of VOC in pol_ef keys.</p> <code>'VOC'</code> <code>pm_name</code> <code>str</code> <p>Name of PM in pol_ef keys.</p> <code>'PM'</code> <code>is_cmaq</code> <code>bool</code> <p>If output for CMAQ.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Spatial and temporal distributed emissions with</p> <code>Dataset</code> <p>VOC and PM speciated.</p> Source code in <code>siem/siem.py</code> <pre><code>def speciate_all(\n    self,\n    cell_area: int | float,\n    voc_name: str = \"VOC\",\n    pm_name: str = \"PM\",\n    is_cmaq: bool = False,\n) -&gt; xr.Dataset:\n    \"\"\"Speciate VOC and PM.\n\n    Args:\n        cell_area: wrfinput cell area.\n        voc_name: Name of VOC in pol_ef keys.\n        pm_name: Name of PM in pol_ef keys.\n        is_cmaq: If output for CMAQ.\n\n    Returns:\n        Spatial and temporal distributed emissions with\n        VOC and PM speciated.\n    \"\"\"\n    spatio_temporal = self.spatiotemporal_emission(\n        self.pol_ef.keys(), cell_area, is_cmaq\n    )\n    speciated_emiss = em.speciate_emission(\n        spatio_temporal, voc_name, self.voc_spc, cell_area\n    )\n    speciated_emiss = em.speciate_emission(\n        speciated_emiss, pm_name, self.pm_spc, cell_area\n    )\n    return speciated_emiss\n</code></pre>"},{"location":"reference/#siem.siem.EmissionSource.speciate_emission","title":"<code>speciate_emission(pol_name, pol_species, cell_area, is_cmaq=False)</code>","text":"<p>Speciate one pollutant emissions. Used especially for VOC or NOX.</p> <p>Parameters:</p> Name Type Description Default <code>pol_name</code> <code>str</code> <p>Pollutant name in pol_ef to speciate.</p> required <code>pol_species</code> <code>dict</code> <p>Keys are pollutants speciated from pol_name. Values are the fraction.</p> required <code>cell_area</code> <code>int | float</code> <p>wrfinput cell area km^2</p> required <code>is_cmaq</code> <code>bool</code> <p>If output is for CMAQ.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>Spatial and temporal distribution of speciated emission.</p> Source code in <code>siem/siem.py</code> <pre><code>def speciate_emission(\n    self,\n    pol_name: str,\n    pol_species: dict,\n    cell_area: int | float,\n    is_cmaq: bool = False,\n) -&gt; xr.DataArray:\n    \"\"\"Speciate one pollutant emissions. Used especially for VOC or NOX.\n\n    Args:\n        pol_name: Pollutant name in pol_ef to speciate.\n        pol_species: Keys are pollutants speciated from pol_name.\n            Values are the fraction.\n        cell_area: wrfinput cell area km^2\n        is_cmaq: If output is for CMAQ.\n\n    Returns:\n        Spatial and temporal distribution of speciated emission.\n    \"\"\"\n    spatio_temporal = self.spatiotemporal_emission(pol_name, cell_area, is_cmaq)\n    speciated_emiss = em.speciate_emission(\n        spatio_temporal, pol_name, pol_species, cell_area\n    )\n    return speciated_emiss\n</code></pre>"},{"location":"reference/#siem.siem.EmissionSource.to_cmaq","title":"<code>to_cmaq(wrfinput, griddesc_path, btrim, start_date, end_date, week_profile=[1], pm_name='PM', voc_name='VOC', write_netcdf=False, path='../results')</code>","text":"<p>Create CMAQ emission file.</p> <p>Parameters:</p> Name Type Description Default <code>wrfinput</code> <code>Dataset</code> <p>wrfinput from WRF simulation.</p> required <code>griddesc_path</code> <code>str</code> <p>Location of GRIDDESC file.</p> required <code>btrim</code> <code>int</code> <p>BTRIM option in MCIP.</p> required <code>start_date</code> <code>str</code> <p>Start date of emission files.</p> required <code>end_date</code> <code>str</code> <p>End date of emission files.</p> required <code>week_profile</code> <code>list[float]</code> <p>List of seven fraction of each week day.</p> <code>[1]</code> <code>pm_name</code> <code>str</code> <p>PM name in pol_ef keys.</p> <code>'PM'</code> <code>voc_name</code> <code>str</code> <p>VOC name in pol_ef keys.</p> <code>'VOC'</code> <code>write_netcdf</code> <code>bool</code> <p>Write the netCDF file.</p> <code>False</code> <code>path</code> <code>str</code> <p>Location to save CMAQ emission file.</p> <code>'../results'</code> <p>Returns:</p> Type Description <code>Dict[str, Dataset]</code> <p>Keys are simulation days and values the emission file for CMAQ</p> <code>Dict[str, Dataset]</code> <p>for that day.</p> Source code in <code>siem/siem.py</code> <pre><code>def to_cmaq(\n    self,\n    wrfinput: xr.Dataset,\n    griddesc_path: str,\n    btrim: int,\n    start_date: str,\n    end_date: str,\n    week_profile: list[float] = [1],\n    pm_name: str = \"PM\",\n    voc_name: str = \"VOC\",\n    write_netcdf: bool = False,\n    path: str = \"../results\",\n) -&gt; typing.Dict[str, xr.Dataset]:\n    \"\"\"Create CMAQ emission file.\n\n    Args:\n        wrfinput: wrfinput from WRF simulation.\n        griddesc_path: Location of GRIDDESC file.\n        btrim: BTRIM option in MCIP.\n        start_date: Start date of emission files.\n        end_date: End date of emission files.\n        week_profile: List of seven fraction of each week day.\n        pm_name: PM name in pol_ef keys.\n        voc_name: VOC name in pol_ef keys.\n        write_netcdf: Write the netCDF file.\n        path: Location to save CMAQ emission file.\n\n    Returns:\n        Keys are simulation days and values the emission file for CMAQ\n        for that day.\n    \"\"\"\n    cell_area = (wrfinput.DX / 1000) ** 2\n    spatio_temporal = self.spatiotemporal_emission(\n        self.pol_ef.keys(), cell_area, is_cmaq=True\n    )\n    spatio_temporal_units = cmaq.transform_cmaq_units(\n        spatio_temporal, self.pol_ef, cell_area\n    )\n    speciated_emiss = cmaq.speciate_cmaq(\n        spatio_temporal_units, self.voc_spc, self.pm_spc, cell_area\n    )\n\n    # TODO: Change it to a function\n    for emi in speciated_emiss.data_vars:\n        speciated_emiss[emi] = speciated_emiss[emi].astype(\"float32\")\n\n    days_factor = temp.assign_factor_simulation_days(\n        start_date, end_date, week_profile, is_cmaq=True\n    )\n    cmaq_files = {\n        day: cmaq.prepare_netcdf_cmaq(\n            speciated_emiss * fact,\n            day,\n            griddesc_path,\n            btrim,\n            self.voc_spc,\n            self.pm_spc,\n        )\n        for day, fact in zip(days_factor.day, days_factor.frac)\n    }\n    if write_netcdf:\n        for cmaq_nc in cmaq_files.values():\n            cmaq.save_cmaq_file(cmaq_nc, path)\n    return cmaq_files\n</code></pre>"},{"location":"reference/#siem.siem.EmissionSource.to_wrfchemi","title":"<code>to_wrfchemi(wrfinput, start_date, end_date, week_profile=[1], pm_name='PM', voc_name='VOC', write_netcdf=False, nc_format='NETCDF3_64BIT', path='../results')</code>","text":"<p>Create WRF-Chem emission file (wrfchemi).</p> <p>Parameters:</p> Name Type Description Default <code>wrfinput</code> <code>Dataset</code> <p>WRF-Chem wrfinput file.</p> required <code>start_date</code> <code>str</code> <p>Start date of emissions.</p> required <code>end_date</code> <code>str</code> <p>End date of emissions.</p> required <code>week_profile</code> <code>list[float]</code> <p>List of seven fraction of each week day.</p> <code>[1]</code> <code>pm_name</code> <code>str</code> <p>PM name in pol_ef keys.</p> <code>'PM'</code> <code>voc_name</code> <code>str</code> <p>VOC name in pol_ef keys</p> <code>'VOC'</code> <code>write_netcdf</code> <code>bool</code> <p>Write the NetCDF file.</p> <code>False</code> <code>nc_format</code> <code>str</code> <p>wrfchemi NetCDF file format.</p> <code>'NETCDF3_64BIT'</code> <code>path</code> <code>str</code> <p>Location to save wrfchemi.</p> <code>'../results'</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset with wrfchemi netCDF format.</p> Source code in <code>siem/siem.py</code> <pre><code>def to_wrfchemi(\n    self,\n    wrfinput: xr.Dataset,\n    start_date: str,\n    end_date: str,\n    week_profile: list[float] = [1],\n    pm_name: str = \"PM\",\n    voc_name: str = \"VOC\",\n    write_netcdf: bool = False,\n    nc_format: str = \"NETCDF3_64BIT\",\n    path: str = \"../results\",\n) -&gt; xr.Dataset:\n    \"\"\"Create WRF-Chem emission file (wrfchemi).\n\n    Args:\n        wrfinput: WRF-Chem wrfinput file.\n        start_date: Start date of emissions.\n        end_date: End date of emissions.\n        week_profile: List of seven fraction of each week day.\n        pm_name: PM name in pol_ef keys.\n        voc_name: VOC name in pol_ef keys\n        write_netcdf: Write the NetCDF file.\n        nc_format: wrfchemi NetCDF file format.\n        path: Location to save wrfchemi.\n\n    Returns:\n        Dataset with wrfchemi netCDF format.\n    \"\"\"\n    cell_area = (wrfinput.DX / 1000) ** 2\n    spatio_temporal = self.spatiotemporal_emission(self.pol_ef.keys(), cell_area)\n    if len(week_profile) == 7:\n        spatio_temporal = temp.split_by_weekday(\n            spatio_temporal, week_profile, start_date, end_date\n        )\n    spatio_temporal = wemi.transform_wrfchemi_units(\n        spatio_temporal, self.pol_ef, pm_name\n    )\n    speciated_emiss = wemi.speciate_wrfchemi(\n        spatio_temporal,\n        self.voc_spc,\n        self.pm_spc,\n        cell_area,\n        wrfinput,\n        voc_name,\n        pm_name,\n    )\n    wrfchemi_netcdf = wemi.prepare_wrfchemi_netcdf(\n        speciated_emiss, wrfinput, start_date\n    )\n\n    if write_netcdf:\n        wemi.write_wrfchemi_netcdf(wrfchemi_netcdf, nc_format, path)\n    return wrfchemi_netcdf\n</code></pre>"},{"location":"reference/#siem.siem.EmissionSource.total_emission","title":"<code>total_emission(pol_name, ktn_year=False)</code>","text":"<p>Calculate total emission of a pollutant.</p> <p>Parameters:</p> Name Type Description Default <code>pol_name</code> <code>str</code> <p>Pollutant name to calculate the total emission.</p> required <code>ktn_year</code> <code>bool</code> <p>If total is calculated in KTn (Gg) year^-1</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>Total emission of a pollutant.</p> Source code in <code>siem/siem.py</code> <pre><code>def total_emission(self, pol_name: str, ktn_year: bool = False) -&gt; float:\n    \"\"\"Calculate total emission of a pollutant.\n\n    Args:\n        pol_name: Pollutant name to calculate the total emission.\n        ktn_year: If total is calculated in KTn (Gg) year^-1\n\n    Returns:\n        Total emission of a pollutant.\n    \"\"\"\n    total_emiss = em.calculate_emission(\n        self.number, self.use_intensity, self.pol_ef[pol_name][0]\n    )\n    # units of total_emiss in g day^-1\n\n    if ktn_year:\n        return total_emiss * 365 / 10**9\n    return total_emiss\n</code></pre>"},{"location":"reference/#siem.siem.GroupSources","title":"<code>GroupSources</code>","text":"<p>A class that group EmissionSources and PointSources object.</p> <p>Attributes     sources_list: A list of EmissionSources and PointSources objects.</p> Source code in <code>siem/siem.py</code> <pre><code>class GroupSources:\n    \"\"\"A class that group EmissionSources and PointSources object.\n\n    Attributes\n        sources_list: A list of EmissionSources and PointSources objects.\n    \"\"\"\n\n    def __init__(self, sources_list: list[EmissionSource | PointSources]):\n        \"\"\"Create a GroupSource object.\n\n        Args:\n            sources_list: List with EmissionSource and PointSources to group.\n        \"\"\"\n        self.sources = {source.name: source for source in sources_list}\n\n    def __str__(self):\n        \"\"\"Print summary of GroupSources attributes.\n\n        Returns:\n            Print number and types of Sources.\n        \"\"\"\n        type_of_sources = [type(source) for source in self.sources.values()]\n        source_summary = (\n            f\"Number of sources: {len(self.names())}\\n\"\n            f\"Type of sources: {set(type_of_sources)}\\n\"\n        )\n        return source_summary\n\n    def names(self):\n        \"\"\"Print names of source emission in GroupSources.\n\n        Returns:\n            Names of source emissions.\n        \"\"\"\n        names = list(self.sources.keys())\n        return names\n\n    def report_emissions(self) -&gt; pd.DataFrame:\n        \"\"\"Return the total emission for each pollutant in pol_emiss.\n\n        Returns:\n            Table with emission source and pollutant as index.\n        \"\"\"\n        total_emissions = {\n            src_name: src.report_emissions() for src_name, src in self.sources.items()\n        }\n        return pd.concat(total_emissions, names=[\"src\", \"pol\"])\n\n    def to_wrfchemi(\n        self,\n        wrfinput: xr.Dataset,\n        start_date: str,\n        end_date: str,\n        week_profile: list[float] = [1],\n        pm_name: str = \"PM\",\n        voc_name: str = \"VOC\",\n        write_netcdf: bool = False,\n        nc_format: str = \"NETCDF3_64BIT\",\n        path: str = \"../results\",\n    ) -&gt; xr.Dataset:\n        \"\"\"Create WRF-Chem emission file.\n\n        Args:\n            wrfinput: WRF-Chem wrfinput.\n            start_date: Start date of emission.\n            end_date: End date of emission.\n            week_profile: Emission weights of days of week.\n            pm_name: PM name in emissions.\n            voc_name: VOC name in emissions.\n            write_netcdf: Save wrfchemi file.\n            nc_format: wrfchemi NetCDF file.\n            path: Location to save wrfchemi file.\n\n        Returns:\n            Emission file in WRF-Chem wrfchemi netCDF format.\n        \"\"\"\n        wrfchemis = {\n            source: emiss.to_wrfchemi(\n                wrfinput,\n                start_date,\n                end_date,\n                week_profile,\n                pm_name,\n                voc_name,\n                write_netcdf=False,\n            )\n            for source, emiss in self.sources.items()\n        }\n        wrfchemi = xr.concat(\n            wrfchemis.values(), pd.Index(wrfchemis.keys(), name=\"source\")\n        )\n        if write_netcdf:\n            wrfchemi = wrfchemi.sum(dim=\"source\", keep_attrs=True)\n            wrfchemi[\"Times\"] = xr.DataArray(\n                wemi.create_date_s19(f\"{start_date}_00:00:00\", wrfchemi.sizes[\"Time\"]),\n                dims=[\"Time\"],\n                coords={\"Time\": wrfchemi.Time.values},\n            )\n            wemi.write_wrfchemi_netcdf(wrfchemi, nc_format, path=path)\n        return wrfchemi\n\n    def to_cmaq(\n        self,\n        wrfinput: xr.Dataset,\n        griddesc_path: str,\n        btrim: int,\n        start_date: str,\n        end_date: str,\n        week_profile: list[float] = [1],\n        pm_name: str = \"PM\",\n        voc_name: str = \"VOC\",\n        write_netcdf: bool = False,\n        path: str = \"../results\",\n    ) -&gt; typing.Dict[str, dict]:\n        \"\"\"Create CMAQ emission file.\n\n        Create CMAQ emission file. All EmissionSource and GroupSources\n        need to have same speciation.\n\n        Args:\n            wrfinput: WRF wrfinput file.\n            griddesc_path: Location of GRIDDESC file.\n            btrim: BTRIM value in MCIP.\n            start_date: Start date of emissions.\n            end_date: End date of emissions.\n            week_profile: Emission weights of days of week.\n            pm_name: PM name in pol_ef or pol_emiss.\n            voc_name: VOC name in pol_ef or pol_emiss.\n            write_netcdf: Save CMAQ emission file.\n            path: Location to save CMAQ emission file.\n\n        Returns::\n            Keys are emission days. Values are emission in CMAQ\n            emission file netCDF format.\n        \"\"\"\n        cmaq_files = {\n            source: emiss.to_cmaq(\n                wrfinput,\n                griddesc_path,\n                btrim,\n                start_date,\n                end_date,\n                week_profile,\n                pm_name,\n                voc_name,\n            )\n            for source, emiss in self.sources.items()\n        }\n        cmaq_source_day = cmaq.merge_cmaq_source_emiss(cmaq_files)\n        sum_sources = cmaq.sum_cmaq_sources(cmaq_source_day)\n        cmaq_sum_by_day = cmaq.update_tflag_sources(sum_sources)\n\n        if write_netcdf:\n            for cmaq_nc in cmaq_sum_by_day.values():\n                cmaq.save_cmaq_file(cmaq_nc, path)\n        return cmaq_sum_by_day\n</code></pre>"},{"location":"reference/#siem.siem.GroupSources.__init__","title":"<code>__init__(sources_list)</code>","text":"<p>Create a GroupSource object.</p> <p>Parameters:</p> Name Type Description Default <code>sources_list</code> <code>list[EmissionSource | PointSources]</code> <p>List with EmissionSource and PointSources to group.</p> required Source code in <code>siem/siem.py</code> <pre><code>def __init__(self, sources_list: list[EmissionSource | PointSources]):\n    \"\"\"Create a GroupSource object.\n\n    Args:\n        sources_list: List with EmissionSource and PointSources to group.\n    \"\"\"\n    self.sources = {source.name: source for source in sources_list}\n</code></pre>"},{"location":"reference/#siem.siem.GroupSources.__str__","title":"<code>__str__()</code>","text":"<p>Print summary of GroupSources attributes.</p> <p>Returns:</p> Type Description <p>Print number and types of Sources.</p> Source code in <code>siem/siem.py</code> <pre><code>def __str__(self):\n    \"\"\"Print summary of GroupSources attributes.\n\n    Returns:\n        Print number and types of Sources.\n    \"\"\"\n    type_of_sources = [type(source) for source in self.sources.values()]\n    source_summary = (\n        f\"Number of sources: {len(self.names())}\\n\"\n        f\"Type of sources: {set(type_of_sources)}\\n\"\n    )\n    return source_summary\n</code></pre>"},{"location":"reference/#siem.siem.GroupSources.names","title":"<code>names()</code>","text":"<p>Print names of source emission in GroupSources.</p> <p>Returns:</p> Type Description <p>Names of source emissions.</p> Source code in <code>siem/siem.py</code> <pre><code>def names(self):\n    \"\"\"Print names of source emission in GroupSources.\n\n    Returns:\n        Names of source emissions.\n    \"\"\"\n    names = list(self.sources.keys())\n    return names\n</code></pre>"},{"location":"reference/#siem.siem.GroupSources.report_emissions","title":"<code>report_emissions()</code>","text":"<p>Return the total emission for each pollutant in pol_emiss.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Table with emission source and pollutant as index.</p> Source code in <code>siem/siem.py</code> <pre><code>def report_emissions(self) -&gt; pd.DataFrame:\n    \"\"\"Return the total emission for each pollutant in pol_emiss.\n\n    Returns:\n        Table with emission source and pollutant as index.\n    \"\"\"\n    total_emissions = {\n        src_name: src.report_emissions() for src_name, src in self.sources.items()\n    }\n    return pd.concat(total_emissions, names=[\"src\", \"pol\"])\n</code></pre>"},{"location":"reference/#siem.siem.GroupSources.to_cmaq","title":"<code>to_cmaq(wrfinput, griddesc_path, btrim, start_date, end_date, week_profile=[1], pm_name='PM', voc_name='VOC', write_netcdf=False, path='../results')</code>","text":"<p>Create CMAQ emission file.</p> <p>Create CMAQ emission file. All EmissionSource and GroupSources need to have same speciation.</p> <p>Parameters:</p> Name Type Description Default <code>wrfinput</code> <code>Dataset</code> <p>WRF wrfinput file.</p> required <code>griddesc_path</code> <code>str</code> <p>Location of GRIDDESC file.</p> required <code>btrim</code> <code>int</code> <p>BTRIM value in MCIP.</p> required <code>start_date</code> <code>str</code> <p>Start date of emissions.</p> required <code>end_date</code> <code>str</code> <p>End date of emissions.</p> required <code>week_profile</code> <code>list[float]</code> <p>Emission weights of days of week.</p> <code>[1]</code> <code>pm_name</code> <code>str</code> <p>PM name in pol_ef or pol_emiss.</p> <code>'PM'</code> <code>voc_name</code> <code>str</code> <p>VOC name in pol_ef or pol_emiss.</p> <code>'VOC'</code> <code>write_netcdf</code> <code>bool</code> <p>Save CMAQ emission file.</p> <code>False</code> <code>path</code> <code>str</code> <p>Location to save CMAQ emission file.</p> <code>'../results'</code> <p>Returns::     Keys are emission days. Values are emission in CMAQ     emission file netCDF format.</p> Source code in <code>siem/siem.py</code> <pre><code>def to_cmaq(\n    self,\n    wrfinput: xr.Dataset,\n    griddesc_path: str,\n    btrim: int,\n    start_date: str,\n    end_date: str,\n    week_profile: list[float] = [1],\n    pm_name: str = \"PM\",\n    voc_name: str = \"VOC\",\n    write_netcdf: bool = False,\n    path: str = \"../results\",\n) -&gt; typing.Dict[str, dict]:\n    \"\"\"Create CMAQ emission file.\n\n    Create CMAQ emission file. All EmissionSource and GroupSources\n    need to have same speciation.\n\n    Args:\n        wrfinput: WRF wrfinput file.\n        griddesc_path: Location of GRIDDESC file.\n        btrim: BTRIM value in MCIP.\n        start_date: Start date of emissions.\n        end_date: End date of emissions.\n        week_profile: Emission weights of days of week.\n        pm_name: PM name in pol_ef or pol_emiss.\n        voc_name: VOC name in pol_ef or pol_emiss.\n        write_netcdf: Save CMAQ emission file.\n        path: Location to save CMAQ emission file.\n\n    Returns::\n        Keys are emission days. Values are emission in CMAQ\n        emission file netCDF format.\n    \"\"\"\n    cmaq_files = {\n        source: emiss.to_cmaq(\n            wrfinput,\n            griddesc_path,\n            btrim,\n            start_date,\n            end_date,\n            week_profile,\n            pm_name,\n            voc_name,\n        )\n        for source, emiss in self.sources.items()\n    }\n    cmaq_source_day = cmaq.merge_cmaq_source_emiss(cmaq_files)\n    sum_sources = cmaq.sum_cmaq_sources(cmaq_source_day)\n    cmaq_sum_by_day = cmaq.update_tflag_sources(sum_sources)\n\n    if write_netcdf:\n        for cmaq_nc in cmaq_sum_by_day.values():\n            cmaq.save_cmaq_file(cmaq_nc, path)\n    return cmaq_sum_by_day\n</code></pre>"},{"location":"reference/#siem.siem.GroupSources.to_wrfchemi","title":"<code>to_wrfchemi(wrfinput, start_date, end_date, week_profile=[1], pm_name='PM', voc_name='VOC', write_netcdf=False, nc_format='NETCDF3_64BIT', path='../results')</code>","text":"<p>Create WRF-Chem emission file.</p> <p>Parameters:</p> Name Type Description Default <code>wrfinput</code> <code>Dataset</code> <p>WRF-Chem wrfinput.</p> required <code>start_date</code> <code>str</code> <p>Start date of emission.</p> required <code>end_date</code> <code>str</code> <p>End date of emission.</p> required <code>week_profile</code> <code>list[float]</code> <p>Emission weights of days of week.</p> <code>[1]</code> <code>pm_name</code> <code>str</code> <p>PM name in emissions.</p> <code>'PM'</code> <code>voc_name</code> <code>str</code> <p>VOC name in emissions.</p> <code>'VOC'</code> <code>write_netcdf</code> <code>bool</code> <p>Save wrfchemi file.</p> <code>False</code> <code>nc_format</code> <code>str</code> <p>wrfchemi NetCDF file.</p> <code>'NETCDF3_64BIT'</code> <code>path</code> <code>str</code> <p>Location to save wrfchemi file.</p> <code>'../results'</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Emission file in WRF-Chem wrfchemi netCDF format.</p> Source code in <code>siem/siem.py</code> <pre><code>def to_wrfchemi(\n    self,\n    wrfinput: xr.Dataset,\n    start_date: str,\n    end_date: str,\n    week_profile: list[float] = [1],\n    pm_name: str = \"PM\",\n    voc_name: str = \"VOC\",\n    write_netcdf: bool = False,\n    nc_format: str = \"NETCDF3_64BIT\",\n    path: str = \"../results\",\n) -&gt; xr.Dataset:\n    \"\"\"Create WRF-Chem emission file.\n\n    Args:\n        wrfinput: WRF-Chem wrfinput.\n        start_date: Start date of emission.\n        end_date: End date of emission.\n        week_profile: Emission weights of days of week.\n        pm_name: PM name in emissions.\n        voc_name: VOC name in emissions.\n        write_netcdf: Save wrfchemi file.\n        nc_format: wrfchemi NetCDF file.\n        path: Location to save wrfchemi file.\n\n    Returns:\n        Emission file in WRF-Chem wrfchemi netCDF format.\n    \"\"\"\n    wrfchemis = {\n        source: emiss.to_wrfchemi(\n            wrfinput,\n            start_date,\n            end_date,\n            week_profile,\n            pm_name,\n            voc_name,\n            write_netcdf=False,\n        )\n        for source, emiss in self.sources.items()\n    }\n    wrfchemi = xr.concat(\n        wrfchemis.values(), pd.Index(wrfchemis.keys(), name=\"source\")\n    )\n    if write_netcdf:\n        wrfchemi = wrfchemi.sum(dim=\"source\", keep_attrs=True)\n        wrfchemi[\"Times\"] = xr.DataArray(\n            wemi.create_date_s19(f\"{start_date}_00:00:00\", wrfchemi.sizes[\"Time\"]),\n            dims=[\"Time\"],\n            coords={\"Time\": wrfchemi.Time.values},\n        )\n        wemi.write_wrfchemi_netcdf(wrfchemi, nc_format, path=path)\n    return wrfchemi\n</code></pre>"},{"location":"reference/#siem.siem.PointSources","title":"<code>PointSources</code>","text":"<p>Point sources.</p> <p>A class to read points emission sources in a table where columns are longitude, latitude, and the total emissions of diferent pollutants in kTn (Gg) year^-1</p> <p>Attributes     name : Name of the point emission sources.     spatial_emission : Spatially distributed emissions in simulation domain.     pol_emiss : Names of considered pollutants (columns).     temporal_prof : Temporal profile to temporal emission distribution.     voc_spc : VOC speciation dict. Keys are VOC species, values are fractions.     pm_spc : PM speciation dict. Keys are PM species, values are fractions.</p> Source code in <code>siem/siem.py</code> <pre><code>class PointSources:\n    \"\"\"Point sources.\n\n    A class to read points emission sources in a\n    table where columns are longitude, latitude, and\n    the total emissions of diferent pollutants in\n    kTn (Gg) year^-1\n\n    Attributes\n        name : Name of the point emission sources.\n        spatial_emission : Spatially distributed emissions in simulation domain.\n        pol_emiss : Names of considered pollutants (columns).\n        temporal_prof : Temporal profile to temporal emission distribution.\n        voc_spc : VOC speciation dict. Keys are VOC species, values are fractions.\n        pm_spc : PM speciation dict. Keys are PM species, values are fractions.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        point_emiss: xr.Dataset,\n        pol_emiss: dict,\n        temporal_prof: list[float],\n        voc_spc: dict,\n        pm_spc: dict,\n    ):\n        \"\"\"Create PointSource  object.\n\n        Args:\n            name: Name of point sources emissions.\n            point_emiss: Points sources in table read with\n            pol_emiss: Keys are columns in point_emiss.\n                Values are the molecular weight.\n            temporal_prof: Hourly fractions to temporally distribute emissions.\n            voc_spc: Keys are VOC species.\n                Values are fractions from the total VOC.\n            pm_spc: Keys are PM species. Values are fractions from the total PM.\n        \"\"\"\n        self.name = name\n        self.spatial_emission = point_emiss\n        self.pol_emiss = pol_emiss\n        self.temporal_prof = temporal_prof\n        self.voc_spc = voc_spc\n        self.pm_spc = pm_spc\n\n    def __str__(self):\n        \"\"\"Print summary of PointSource attributes.\n\n        Returns:\n            Print name, number, pollutants,\n            and VOC and PM species information\n            from EmissionSource.\n        \"\"\"\n        source_summary = (\n            f\"Source name: {self.name}\\n\"\n            f\"Pollutants: {list(self.pol_emiss.keys())}\\n\"\n            f\"Number VOC species: {len(self.voc_spc.keys())}\\n\"\n            f\"Number PM species: {len(self.pm_spc.keys())}\\n\"\n        )\n        return source_summary\n\n    def total_emission(self, pol_name: str) -&gt; float:\n        \"\"\"Calculate total emission of a pollutant.\n\n        Args:\n            pol_name: Pollutant name to calculate the total emission.\n\n        Returns:\n            Total emission of a pollutant in KTn (Gg) year^-1\n        \"\"\"\n        if pol_name in self.pol_emiss.keys():\n            return self.spatial_emission[pol_name].sum().values\n        else:\n            print(f\"{pol_name} not include in data\")\n\n    def report_emissions(self) -&gt; pd.DataFrame:\n        \"\"\"Return the total emission for each pollutant in pol_ef.\n\n        Returns:\n            A table with pollutants as index and total emissions\n            as columns.\n        \"\"\"\n        total_emission = {\n            pol: self.total_emission(pol) for pol in self.pol_emiss.keys()\n        }\n        total_emission = pd.DataFrame.from_dict(\n            total_emission, orient=\"index\", columns=[\"total_emiss\"]\n        )\n        return total_emission\n\n    def to_wrfchemi(\n        self,\n        wrfinput: xr.Dataset,\n        start_date: str,\n        end_date: str,\n        week_profile: list[float] = [1],\n        pm_name: str = \"PM\",\n        voc_name: str = \"VOC\",\n        write_netcdf: bool = False,\n        nc_format: str = \"NETCDF3_64BIT\",\n        path: str = \"../results/\",\n    ) -&gt; xr.Dataset:\n        \"\"\"Create WRF-Chem emission file.\n\n        Args:\n            wrfinput: WRF wrfinput.\n            start_date: Start date of emission.\n            end_date: End date of emission.\n            week_profile: Emission weights of days of week.\n            pm_name: PM name in pol_emiss.\n            voc_name: VOC name in pol_emiss.\n            write_netcdf: Write wrfchemi netCDF.\n            nc_format: wrfchemi NetCDF file format.\n            path: Location to save wrfchemi files.\n\n        Returns:\n            Emission file in wrfchemi netCDF format.\n        \"\"\"\n        cell_area = (wrfinput.DX / 1000) ** 2\n        point_gd = em.ktn_year_to_g_day(self.spatial_emission)  # g day^-1\n        point_gh = temp.split_by_time_from(point_gd, self.temporal_prof)  # g hr^-1\n        point_spc_time = wemi.transform_wrfchemi_units_point(\n            point_gh, self.pol_emiss, cell_area\n        )\n        if len(week_profile) == 7:\n            point_spc_time = temp.split_by_weekday(\n                point_spc_time, week_profile, start_date, end_date\n            )\n        point_speciated = wemi.speciate_wrfchemi(\n            point_spc_time, self.voc_spc, self.pm_spc, cell_area, wrfinput\n        )\n        wrfchemi_netcdf = wemi.prepare_wrfchemi_netcdf(\n            point_speciated, wrfinput, start_date\n        )\n        if write_netcdf:\n            wemi.write_wrfchemi_netcdf(wrfchemi_netcdf, nc_format, path)\n        return wrfchemi_netcdf\n\n    def to_cmaq(\n        self,\n        wrfinput: xr.Dataset,\n        griddesc_path: str,\n        btrim: int,\n        start_date: str,\n        end_date: str,\n        week_profile: list[float] = [1],\n        pm_name: str = \"PM\",\n        voc_name: str = \"VOC\",\n        write_netcdf: bool = False,\n        path: str = \"../results\",\n    ) -&gt; typing.Dict[str, xr.Dataset]:\n        \"\"\"Create CMAQ emission file.\n\n        Create and save CMAQ emission file.\n\n        Args:\n            wrfinput: WRF wrfinput.\n            griddesc_path: Location of GRIDDESC file.\n            btrim: BTRIM value in MCIP.\n            start_date: Start date of emission.\n            end_date: End date of emission.\n            week_profile: Emission weights of days of week.\n            pm_name: PM name in pol_emiss.\n            voc_name: VOC name in pol_emiss.\n            write_netcdf: Save CMAQ emission file.\n            path: Location to save CMAQ emission file.\n        Returns:\n            Keys are simulation day.\n            Values are Daset in CMAQ emission file netcdf format.\n        \"\"\"\n        cell_area = (wrfinput.DX / 1000) ** 2\n        point_gd = em.ktn_year_to_g_day(self.spatial_emission)  # g day^-1\n        cmaq_temp_prof = cmaq.to_25hr_profile(self.temporal_prof)\n        point_time = temp.split_by_time_from(\n            point_gd,  # g hr^-1\n            cmaq_temp_prof,\n        )\n\n        point_time_units = cmaq.transform_cmaq_units_point(\n            point_time, self.pol_emiss, pm_name\n        )\n        speciated_emiss = cmaq.speciate_cmaq(\n            point_time_units, self.voc_spc, self.pm_spc, cell_area\n        )\n        for emi in speciated_emiss.data_vars:\n            speciated_emiss[emi] = speciated_emiss[emi].astype(\"float32\")\n\n        days_factor = temp.assign_factor_simulation_days(\n            start_date, end_date, week_profile, is_cmaq=True\n        )\n        cmaq_files = {\n            day: cmaq.prepare_netcdf_cmaq(\n                speciated_emiss * fact,\n                day,\n                griddesc_path,\n                btrim,\n                self.voc_spc,\n                self.pm_spc,\n            )\n            for day, fact in zip(days_factor.day, days_factor.frac)\n        }\n        if write_netcdf:\n            for cmaq_nc in cmaq_files.values():\n                cmaq.save_cmaq_file(cmaq_nc, path)\n        return cmaq_files\n</code></pre>"},{"location":"reference/#siem.siem.PointSources.__init__","title":"<code>__init__(name, point_emiss, pol_emiss, temporal_prof, voc_spc, pm_spc)</code>","text":"<p>Create PointSource  object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of point sources emissions.</p> required <code>point_emiss</code> <code>Dataset</code> <p>Points sources in table read with</p> required <code>pol_emiss</code> <code>dict</code> <p>Keys are columns in point_emiss. Values are the molecular weight.</p> required <code>temporal_prof</code> <code>list[float]</code> <p>Hourly fractions to temporally distribute emissions.</p> required <code>voc_spc</code> <code>dict</code> <p>Keys are VOC species. Values are fractions from the total VOC.</p> required <code>pm_spc</code> <code>dict</code> <p>Keys are PM species. Values are fractions from the total PM.</p> required Source code in <code>siem/siem.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    point_emiss: xr.Dataset,\n    pol_emiss: dict,\n    temporal_prof: list[float],\n    voc_spc: dict,\n    pm_spc: dict,\n):\n    \"\"\"Create PointSource  object.\n\n    Args:\n        name: Name of point sources emissions.\n        point_emiss: Points sources in table read with\n        pol_emiss: Keys are columns in point_emiss.\n            Values are the molecular weight.\n        temporal_prof: Hourly fractions to temporally distribute emissions.\n        voc_spc: Keys are VOC species.\n            Values are fractions from the total VOC.\n        pm_spc: Keys are PM species. Values are fractions from the total PM.\n    \"\"\"\n    self.name = name\n    self.spatial_emission = point_emiss\n    self.pol_emiss = pol_emiss\n    self.temporal_prof = temporal_prof\n    self.voc_spc = voc_spc\n    self.pm_spc = pm_spc\n</code></pre>"},{"location":"reference/#siem.siem.PointSources.__str__","title":"<code>__str__()</code>","text":"<p>Print summary of PointSource attributes.</p> <p>Returns:</p> Type Description <p>Print name, number, pollutants,</p> <p>and VOC and PM species information</p> <p>from EmissionSource.</p> Source code in <code>siem/siem.py</code> <pre><code>def __str__(self):\n    \"\"\"Print summary of PointSource attributes.\n\n    Returns:\n        Print name, number, pollutants,\n        and VOC and PM species information\n        from EmissionSource.\n    \"\"\"\n    source_summary = (\n        f\"Source name: {self.name}\\n\"\n        f\"Pollutants: {list(self.pol_emiss.keys())}\\n\"\n        f\"Number VOC species: {len(self.voc_spc.keys())}\\n\"\n        f\"Number PM species: {len(self.pm_spc.keys())}\\n\"\n    )\n    return source_summary\n</code></pre>"},{"location":"reference/#siem.siem.PointSources.report_emissions","title":"<code>report_emissions()</code>","text":"<p>Return the total emission for each pollutant in pol_ef.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A table with pollutants as index and total emissions</p> <code>DataFrame</code> <p>as columns.</p> Source code in <code>siem/siem.py</code> <pre><code>def report_emissions(self) -&gt; pd.DataFrame:\n    \"\"\"Return the total emission for each pollutant in pol_ef.\n\n    Returns:\n        A table with pollutants as index and total emissions\n        as columns.\n    \"\"\"\n    total_emission = {\n        pol: self.total_emission(pol) for pol in self.pol_emiss.keys()\n    }\n    total_emission = pd.DataFrame.from_dict(\n        total_emission, orient=\"index\", columns=[\"total_emiss\"]\n    )\n    return total_emission\n</code></pre>"},{"location":"reference/#siem.siem.PointSources.to_cmaq","title":"<code>to_cmaq(wrfinput, griddesc_path, btrim, start_date, end_date, week_profile=[1], pm_name='PM', voc_name='VOC', write_netcdf=False, path='../results')</code>","text":"<p>Create CMAQ emission file.</p> <p>Create and save CMAQ emission file.</p> <p>Parameters:</p> Name Type Description Default <code>wrfinput</code> <code>Dataset</code> <p>WRF wrfinput.</p> required <code>griddesc_path</code> <code>str</code> <p>Location of GRIDDESC file.</p> required <code>btrim</code> <code>int</code> <p>BTRIM value in MCIP.</p> required <code>start_date</code> <code>str</code> <p>Start date of emission.</p> required <code>end_date</code> <code>str</code> <p>End date of emission.</p> required <code>week_profile</code> <code>list[float]</code> <p>Emission weights of days of week.</p> <code>[1]</code> <code>pm_name</code> <code>str</code> <p>PM name in pol_emiss.</p> <code>'PM'</code> <code>voc_name</code> <code>str</code> <p>VOC name in pol_emiss.</p> <code>'VOC'</code> <code>write_netcdf</code> <code>bool</code> <p>Save CMAQ emission file.</p> <code>False</code> <code>path</code> <code>str</code> <p>Location to save CMAQ emission file.</p> <code>'../results'</code> <p>Returns:     Keys are simulation day.     Values are Daset in CMAQ emission file netcdf format.</p> Source code in <code>siem/siem.py</code> <pre><code>def to_cmaq(\n    self,\n    wrfinput: xr.Dataset,\n    griddesc_path: str,\n    btrim: int,\n    start_date: str,\n    end_date: str,\n    week_profile: list[float] = [1],\n    pm_name: str = \"PM\",\n    voc_name: str = \"VOC\",\n    write_netcdf: bool = False,\n    path: str = \"../results\",\n) -&gt; typing.Dict[str, xr.Dataset]:\n    \"\"\"Create CMAQ emission file.\n\n    Create and save CMAQ emission file.\n\n    Args:\n        wrfinput: WRF wrfinput.\n        griddesc_path: Location of GRIDDESC file.\n        btrim: BTRIM value in MCIP.\n        start_date: Start date of emission.\n        end_date: End date of emission.\n        week_profile: Emission weights of days of week.\n        pm_name: PM name in pol_emiss.\n        voc_name: VOC name in pol_emiss.\n        write_netcdf: Save CMAQ emission file.\n        path: Location to save CMAQ emission file.\n    Returns:\n        Keys are simulation day.\n        Values are Daset in CMAQ emission file netcdf format.\n    \"\"\"\n    cell_area = (wrfinput.DX / 1000) ** 2\n    point_gd = em.ktn_year_to_g_day(self.spatial_emission)  # g day^-1\n    cmaq_temp_prof = cmaq.to_25hr_profile(self.temporal_prof)\n    point_time = temp.split_by_time_from(\n        point_gd,  # g hr^-1\n        cmaq_temp_prof,\n    )\n\n    point_time_units = cmaq.transform_cmaq_units_point(\n        point_time, self.pol_emiss, pm_name\n    )\n    speciated_emiss = cmaq.speciate_cmaq(\n        point_time_units, self.voc_spc, self.pm_spc, cell_area\n    )\n    for emi in speciated_emiss.data_vars:\n        speciated_emiss[emi] = speciated_emiss[emi].astype(\"float32\")\n\n    days_factor = temp.assign_factor_simulation_days(\n        start_date, end_date, week_profile, is_cmaq=True\n    )\n    cmaq_files = {\n        day: cmaq.prepare_netcdf_cmaq(\n            speciated_emiss * fact,\n            day,\n            griddesc_path,\n            btrim,\n            self.voc_spc,\n            self.pm_spc,\n        )\n        for day, fact in zip(days_factor.day, days_factor.frac)\n    }\n    if write_netcdf:\n        for cmaq_nc in cmaq_files.values():\n            cmaq.save_cmaq_file(cmaq_nc, path)\n    return cmaq_files\n</code></pre>"},{"location":"reference/#siem.siem.PointSources.to_wrfchemi","title":"<code>to_wrfchemi(wrfinput, start_date, end_date, week_profile=[1], pm_name='PM', voc_name='VOC', write_netcdf=False, nc_format='NETCDF3_64BIT', path='../results/')</code>","text":"<p>Create WRF-Chem emission file.</p> <p>Parameters:</p> Name Type Description Default <code>wrfinput</code> <code>Dataset</code> <p>WRF wrfinput.</p> required <code>start_date</code> <code>str</code> <p>Start date of emission.</p> required <code>end_date</code> <code>str</code> <p>End date of emission.</p> required <code>week_profile</code> <code>list[float]</code> <p>Emission weights of days of week.</p> <code>[1]</code> <code>pm_name</code> <code>str</code> <p>PM name in pol_emiss.</p> <code>'PM'</code> <code>voc_name</code> <code>str</code> <p>VOC name in pol_emiss.</p> <code>'VOC'</code> <code>write_netcdf</code> <code>bool</code> <p>Write wrfchemi netCDF.</p> <code>False</code> <code>nc_format</code> <code>str</code> <p>wrfchemi NetCDF file format.</p> <code>'NETCDF3_64BIT'</code> <code>path</code> <code>str</code> <p>Location to save wrfchemi files.</p> <code>'../results/'</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Emission file in wrfchemi netCDF format.</p> Source code in <code>siem/siem.py</code> <pre><code>def to_wrfchemi(\n    self,\n    wrfinput: xr.Dataset,\n    start_date: str,\n    end_date: str,\n    week_profile: list[float] = [1],\n    pm_name: str = \"PM\",\n    voc_name: str = \"VOC\",\n    write_netcdf: bool = False,\n    nc_format: str = \"NETCDF3_64BIT\",\n    path: str = \"../results/\",\n) -&gt; xr.Dataset:\n    \"\"\"Create WRF-Chem emission file.\n\n    Args:\n        wrfinput: WRF wrfinput.\n        start_date: Start date of emission.\n        end_date: End date of emission.\n        week_profile: Emission weights of days of week.\n        pm_name: PM name in pol_emiss.\n        voc_name: VOC name in pol_emiss.\n        write_netcdf: Write wrfchemi netCDF.\n        nc_format: wrfchemi NetCDF file format.\n        path: Location to save wrfchemi files.\n\n    Returns:\n        Emission file in wrfchemi netCDF format.\n    \"\"\"\n    cell_area = (wrfinput.DX / 1000) ** 2\n    point_gd = em.ktn_year_to_g_day(self.spatial_emission)  # g day^-1\n    point_gh = temp.split_by_time_from(point_gd, self.temporal_prof)  # g hr^-1\n    point_spc_time = wemi.transform_wrfchemi_units_point(\n        point_gh, self.pol_emiss, cell_area\n    )\n    if len(week_profile) == 7:\n        point_spc_time = temp.split_by_weekday(\n            point_spc_time, week_profile, start_date, end_date\n        )\n    point_speciated = wemi.speciate_wrfchemi(\n        point_spc_time, self.voc_spc, self.pm_spc, cell_area, wrfinput\n    )\n    wrfchemi_netcdf = wemi.prepare_wrfchemi_netcdf(\n        point_speciated, wrfinput, start_date\n    )\n    if write_netcdf:\n        wemi.write_wrfchemi_netcdf(wrfchemi_netcdf, nc_format, path)\n    return wrfchemi_netcdf\n</code></pre>"},{"location":"reference/#siem.siem.PointSources.total_emission","title":"<code>total_emission(pol_name)</code>","text":"<p>Calculate total emission of a pollutant.</p> <p>Parameters:</p> Name Type Description Default <code>pol_name</code> <code>str</code> <p>Pollutant name to calculate the total emission.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Total emission of a pollutant in KTn (Gg) year^-1</p> Source code in <code>siem/siem.py</code> <pre><code>def total_emission(self, pol_name: str) -&gt; float:\n    \"\"\"Calculate total emission of a pollutant.\n\n    Args:\n        pol_name: Pollutant name to calculate the total emission.\n\n    Returns:\n        Total emission of a pollutant in KTn (Gg) year^-1\n    \"\"\"\n    if pol_name in self.pol_emiss.keys():\n        return self.spatial_emission[pol_name].sum().values\n    else:\n        print(f\"{pol_name} not include in data\")\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p><code>siem</code> works with three classes to define our emissions:</p> <ul> <li><code>EmissionSource</code>: Mainly built to calculate and distribute vehicular emissions using a spatial proxy.</li> <li><code>PointSource</code>: Mainly built to distribute point emissions that are loaded in a table (i.e. <code>.csv</code> file).</li> <li><code>GroupSources</code>: Built to merge all the <code>EmissionSource</code> and <code>PointSource</code> object in one single object. Useful to create the final emission that goes to the air quality model.</li> </ul> <p>Each of theses objects has the <code>.to_wrfchem</code> and <code>.to_cmaq</code> methods that allows to create the emission file for WRF-Chem and CMAQ respectively.</p>"},{"location":"tutorials/#defining-emissions-attributes","title":"Defining emissions attributes","text":"<p>Because emissions varies in space, in time, in species, these factors need to be defined in <code>EmissionSource</code> and <code>PointSource</code> attributes. Let's start by explaining how to define them.</p>"},{"location":"tutorials/#spatial-proxy","title":"Spatial proxy","text":"<p>The spatial proxy is a file that have the weights (ratios) to spatially distribute an n number of sources (i.e. vehicles) in the simulation domain. For that reason it is required to have the same number of <code>west_east</code> and <code>south_north</code> points in the <code>wrfinput</code> file.</p> <p>A spatial proxy file has the following format:</p> <pre><code>159 -46.60239219665527 -24.044368743896484 0.0\n160 -46.59200668334961 -24.044368743896484 0.0\n161 -46.581621170043945 -24.044368743896484 0.0\n162 -46.57123374938965 -24.044368743896484 0.0\n163 -46.560848236083984 -24.044368743896484 0.0\n164 -46.55046272277832 -24.044368743896484 0.0\n165 -46.54007530212402 -24.044368743896484 1.7393638309449484\n166 -46.52968978881836 -24.044368743896484 4.358224109569712\n167 -46.519304275512695 -24.044368743896484 2.098392445514633\n168 -46.5089168548584 -24.044368743896484 0.0\n169 -46.498531341552734 -24.044368743896484 0.0\n</code></pre> <p>The first column is the id, the second column is the longitude, the third column is the latitude, and the fourth column is the weight of the emissions sources.</p> <p>So, to prepare these file to be used in <code>EmissionSource</code>, we use the <code>read_spatial_proxy()</code> function from the <code>spatial</code> module. Let's imagine that the proxy represents the gasoline vehicles.</p> <pre><code>from siem.spatial import read_spatial_proxy\n\ngasoline_spatial_proxy = read_spatial_proxy(\n  proxy_path='./highways_data/highways_d01.csv',\n  shape=(100, 100),\n  col_names=['id', 'x', 'y', 'emiss_weight'],\n  proxy='emiss_weight',\n  lon_name='x',\n  lan_name='y'\n)\n</code></pre>"},{"location":"tutorials/#temporal-profile","title":"Temporal profile","text":"<p>The temporal is just a list with at least 24 elements (hourly weight), one for each hour of the day. It has to be in UTC.</p> <p>For example a temporal profile for gasoline vehicles can be defined as:</p> <pre><code>gasoline_temp_prof = [\n    0.020, 0.010, 0.010, 0.004, 0.003, 0.003,\n    0.010, 0.020, 0.050, 0.080, 0.080, 0.064,\n    0.060, 0.052, 0.050, 0.050, 0.050, 0.057,\n    0.070, 0.090, 0.090, 0.060, 0.040, 0.034\n    ]\n</code></pre> <p>The temporal profile can also be a column of a data frame.</p>"},{"location":"tutorials/#pollutant-emission-factors","title":"Pollutant emission factors","text":"<p>The pollutant emission factors are defined using a <code>dict()</code>. The dictionary keys are the names of pollutants in the emission inventory. The dictionary values are a <code>tuple</code> where the first element is the emission factors (g day^-1), and the second element is the molecular weight (g mol^-1).</p> <p>Following the gasoline vehicles, we can define its emission factors as:</p> <pre><code>gasoline_ef = {\n  \"CO\": (0.173, 28),\n  \"NO\": (0.010, 30),\n  \"RCHO\": (0.0005, 32),\n  \"VOC\": (0.012, 100),\n  \"PM\": (0.001,1)\n}\n</code></pre> <p>In this example, we define the emission factor of CO (carbon monoxide), NO (nitrogen monoxide), RCHO (aldehydes), VOC (Volatile Organic Compound), and PM (Particulate Matter).</p> <p>About VOC and PM emission factors</p> <p>It is required to have \"VOC\" and \"PM\" keys on the dictionary, as they will be latter speciated. If there is no information, you can zero them by using <code>VOC: (0, 100)</code> or <code>PM: (0, 1)</code>. Also, PM molecular weight is always 1.</p>"},{"location":"tutorials/#voc-and-pm-speciation","title":"VOC and PM speciation","text":"<p>Many chemical mechanisms and aerosol modules use different species for both VOC and PM. <code>siem</code> speciation is based on percentage of total emissions. The speciation is also saved in a <code>dict()</code>, where the keys are the VOC or PM species of the selected chemical mechanism or module aerosol, and the values are the percentage of the total VOC or PM emissions.</p> <p>For example, for CBMZ and MOSAIC we can have:</p> <pre><code>gasoline_voc_cbmz = {\n    \"ETH\": 0.282625, \"HC3\": 0.435206, \"HC5\": 0.158620,\n    \"HC8\": 0.076538, \"OL2\": 0.341600, \"OLT\": 0.143212,\n    \"OLI\": 0.161406, \"ISO\": 0.004554, \"TOL\": 0.140506,\n    \"XYL\": 0.157456, \"KET\": 0.000083, \"CH3OH\": 0.001841\n}\n\ngasoline_pm_mosaic = {\n    \"PM25I\": 0.032,\n    \"PM25J\": 0.096,\n    \"SO4I\": 0.0024,\n    \"SO4J\": 0.0156,\n    ....\n}\n</code></pre> <p>Therefore, <code>siem</code> can be used for different chemical mechanism as the speciation is defined by the user and the available information.</p>"},{"location":"tutorials/#creating-an-emissionsource-object","title":"Creating an <code>EmissionSource</code> object","text":"<p>Once we have and prepare the emission information, we can now create the object. In the following example, We will create an <code>EmissionSource</code> object that save information of all the gasoline vehicles of a city. Let's imagine that there are 1 000 000 of these vehicles, and on average they run 13 495 km per year. So:</p> <pre><code>from siem.siem import EmissionSource\n\ngasoline = EmissionSource(\n    name=\"Gasoline vehicles\",\n    number=1_000_000,\n    use_intensity= 13_495/365,  # km day ^ -1\n    pol_ef=gasoline_ef,\n    spatial_proxy=gasoline_spatial_proxy,\n    temporal_profile=temp_prof,\n    voc_spc=gasoline_voc_cbmz,\n    pm_spc=gasoline_pm_mosaic\n)\n</code></pre> <p>We can create another object with the information of diesel vehicles. Let us assume that there are 40 000 diesel vehicles that run the same as the gasoline vehicles.</p> <pre><code>diesel = EmissionSource(\n    name=\"Diesel vehicles\",\n    number=40_000,\n    use_intensity= 13_495/365,  # km day ^ -1\n    pol_ef=diesel_ef,\n    spatial_proxy=diesel_spatial_proxy,\n    temporal_profile=diesel_temp_prof,\n    voc_spc=diesel_voc_cbmz,\n    pm_spc=diesel_pm_mosaic\n)\n</code></pre> <p>About the diesel example</p> <p>Notice that <code>diesel</code> is define using different attributes (i.e. different spatial proxy, temporal profile, speciation, etc). If you have the information each EmissionSource can have different  attributes, otherwise, you can repeat the attributes for other EmissionSource.</p>"},{"location":"tutorials/#creating-an-pointsource-object","title":"Creating an <code>PointSource</code> object","text":"<p>Now, if you have an emission file in <code>.csv</code> with point information total emission (kT year^-1), you can use <code>PointSource</code> to load the emissions, but first you need to read the <code>.csv</code></p>"},{"location":"tutorials/#reading-point-source-csv-file","title":"Reading point source <code>.csv</code> file","text":"<p>We use the function <code>read_point_sources()</code> from <code>point</code> module to prepare our <code>.csv</code> file. This function will sum each of the point sources located inside domain cells.</p> <pre><code>import xarray as xr\nfrom siem.point import read_point_sources\n\ngeogrid = xr.open_dataset('./geo_em.d01.nc')\n_, nrow, ncol = geo.XLAT_M.shape\n\npoint_dom = read_point_sources(\n  point_path='./city_industries.tsv',\n  geo_path='./geo_em.d01.nc',\n  ncol=ncol, \n  nrow=nrow,\n  sep='\\t', \n  lat_name='LAT',\n  lon_name='LON'\n)\n</code></pre>"},{"location":"tutorials/#defining-emission-molecular-weight","title":"Defining emission molecular weight","text":"<p>Because the <code>.csv</code> file already have the total emissions calculate, we do not need the emission factors, <code>PointSource</code> only needs the molecular weight of the emissions. We define it using a <code>dict()</code>.</p> <pre><code>pol_mw = {\n  'CO': 12 + 14,\n  'SO2': 32 + 2 * 16,\n  'NO2': 14 + 2 * 16,\n  'VOC': 100, \n  'PM': 1\n}\n</code></pre> <p>About VOC and PM molecular weight</p> <p>As in the case of <code>EmissionSource</code>, it is required to have \"VOC\" and \"PM\" keys on the dictionary, as they will be latter speciated.</p>"},{"location":"tutorials/#defining-pointsource","title":"Defining <code>PointSource</code>","text":"<p>Now we can create our <code>PointSource</code> as following:</p> <pre><code>city_point_source = PointSources(\n  name='City industries',\n  point_emiss=point_dom,\n  pol_emiss=pol_mw,\n  temporal_profile=ind_temp_prof,\n  voc_spc=ind_voc_cbmz,\n  pm_spc=ind_pm_cbmz\n)\n</code></pre> <p><code>temporal_profile</code>, <code>voc_spc</code>, and <code>pm_spc</code> are defined the same as in <code>EmissionSource</code>.</p>"},{"location":"tutorials/#creating-a-groupsources-object","title":"Creating a <code>GroupSources</code> object","text":"<p>Once you defined all the emissions sources in your domain, you need to group all of them to built the anthropogenic emission file require to run the air quality models. To that goal we used <code>GroupSources</code>.</p> <p>Following what we build in this tutorial, we can do the following:</p> <pre><code>from siem.siem import GroupSources\n\ncity_sources = [city_point_source, gasoline, diesel]\ncity_anthro_emiss = GroupSources(city_sources)\n</code></pre> <p>That's it!</p> <p>Now if you want to create emission files for WRF-Chem, you can do:</p> <pre><code>import xarray as xr\nwrfinput_d01 = xr.open_dataset('./wrfinput_d01')\n\ncity_anthro_emiss.to_wrfchemi(\n  wrfinput=wrfinput_d01,\n  start_date='2025-10-01',\n  end_date='2025-10-01',\n  week_profile=week_profile,\n  write_netcdf=True\n)\n</code></pre> <p>And for CMAQ:</p> <pre><code>import xarray as xr\nwrfinput_d01 = xr.open_dataset('./wrfinput_d01')\n\n\ncity_anthro_emiss.to_wrfchemi(\n  wrfinput=wrfinput_d01,\n  griddesc_path='./GRIDDESC',\n  btrim=5,\n  start_date='2025-10-01',\n  end_date='2025-10-01',\n  week_profile= week_profile,\n  write_netcdf=True\n)\n</code></pre>"}]}